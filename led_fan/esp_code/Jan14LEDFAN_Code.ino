//Defining the Letters as Boolean matrices
boolean A[5][4]={
   {1,1,1,1},   
   {1,0,0,1},   
   {1,1,1,1},
   {1,0,0,1},
   {1,0,0,1}   
};

boolean B[5][4]={
   {1,1,1,0},   
   {1,0,0,1},   
   {1,1,1,1},
   {1,0,0,1},
   {1,1,1,0}   
};

boolean C[5][4]={
   {1,1,1,1},   
   {1,0,0,0},   
   {1,0,0,0},
   {1,0,0,0},
   {1,1,1,1}   
};
boolean D[5][5] = {  
   {1,1,1,1,0},   
   {1,0,0,0,1},   
   {1,0,0,0,1},
   {1,0,0,0,1},
   {1,1,1,1,0}   
};

boolean E[5][4]={
   {1,1,1,1},   
   {1,0,0,0},   
   {1,1,1,1},
   {1,0,0,0},
   {1,1,1,1}   
};

boolean F[5][4]={
   {1,1,1,1},   
   {1,0,0,0},   
   {1,1,1,1},
   {1,0,0,0},
   {1,0,0,0}   
};

boolean G[5][5]={
   {1,1,1,1,1},   
   {1,0,0,0,0},   
   {1,0,1,1,1},
   {1,0,1,0,1},
   {1,1,1,1,1}   
};

boolean H[5][4]={
   {1,0,0,1},   
   {1,0,0,1},   
   {1,1,1,1},
   {1,0,0,1},
   {1,0,0,1}   
};

boolean I[5][5]={
   {1,1,1,1,1},   
   {0,0,1,0,0},   
   {0,0,1,0,0},
   {0,0,1,0,0},
   {1,1,1,1,1}   
};

boolean J[5][5]={
   {1,1,1,1,1},   
   {0,0,1,0,0},   
   {0,0,1,0,0},
   {1,0,1,0,0},
   {1,1,1,0,0}   
};

boolean K[5][4]={
   {1,0,0,1},   
   {1,0,1,0},   
   {1,1,0,0},
   {1,0,1,0},
   {1,0,0,1}   
};

boolean L[5][4]={
   {1,0,0,0},   
   {1,0,0,0},   
   {1,0,0,0},
   {1,0,0,0},
   {1,1,1,1}   
};

boolean M[5][5] = {  
   {1,0,0,0,1},   
   {1,1,0,1,1},   
   {1,0,1,0,1},
   {1,0,0,0,1},
   {1,0,0,0,1}   
};

boolean P[5][4]={
   {1,1,1,1},   
   {1,0,0,1},   
   {1,1,1,1},
   {1,0,0,0},
   {1,0,0,0}   
};
boolean Q[5][5] = {  
   {1,1,1,1,0},   
   {1,0,0,1,0},   
   {1,0,1,1,0},
   {1,1,1,1,0},
   {0,0,0,0,1}   
};
boolean R[5][4] = {  
   {1,1,1,1},   
   {1,0,0,1},   
   {1,1,1,1},
   {1,0,1,0},
   {1,0,0,1}   
};

boolean S[5][4]={
   {1,1,1,1},   
   {1,0,0,0},   
   {1,1,1,1},
   {0,0,0,1},
   {1,1,1,1}   
};

boolean T[5][5]={
   {1,1,1,1,1},   
   {0,0,1,0,0},   
   {0,0,1,0,0},
   {0,0,1,0,0},
   {0,0,1,0,0}   
};

boolean U[5][4]={
   {1,0,0,1},   
   {1,0,0,1},   
   {1,0,0,1},
   {1,0,0,1},
   {1,1,1,1}   
};

boolean V[5][5]={
   {1,0,0,0,1},   
   {1,0,0,0,1},   
   {1,0,0,0,1},
   {0,1,0,1,0},
   {0,0,1,0,0}   
};

boolean W[5][5]={
   {1,0,0,0,1},   
   {1,0,0,0,1},   
   {1,0,1,0,1},
   {1,1,0,1,1},
   {1,0,0,0,1}   
};

boolean X[5][5]={
   {1,0,0,0,1},   
   {0,1,0,1,0},   
   {0,0,1,0,0},
   {0,1,0,1,0},
   {1,0,0,0,1}   
};
boolean Y[5][5] = {  
   {1,0,0,0,1},   
   {0,1,0,1,0},   
   {0,0,1,0,0},
   {0,0,1,0,0},
   {0,0,1,0,0}   
};

boolean Z[5][5]={
   {1,1,1,1,1},   
   {0,0,0,1,0},   
   {0,0,1,0,0},
   {0,1,0,0,0},
   {1,1,1,1,1}   
};

boolean exc[5][5] = {  
   {1,1,1,1,1},   
   {1,1,1,1,1},   
   {1,1,1,1,1},
   {0,0,0,0,0},
   {1,1,1,1,1}   
};


boolean O[5][4] = {  
   {1,1,1,1},   
   {1,0,0,1},   
   {1,0,0,1},
   {1,0,0,1},
   {1,1,1,1}   
};

boolean N[5][5] = {  
   {1,0,0,0,1},   
   {1,1,0,0,1},   
   {1,0,1,0,1},
   {1,0,0,1,1},
   {1,0,0,0,1}   
};


boolean space[5][2] = {  
   {0,0},   
   {0,0},   
   {0,0},
   {0,0},
   {0,0}   
};




// Defining Variables
float pi=3.14159;
const int LED[5]={0,1,2,3,4};
int t_on;
int t_off;
int w;
int thresh=550;
float t_0;
float t_1;
int i;
int rev=0;
int subcount;
int width;
int height;
const int hall=0;// this is 0 because analogread(0) reads pin 5



int rad=20;//fan radius in cm
int tol=1;//spacing between letter components in cm





void setup() {
  // put your setup code here, to run once:
  //Serial.begin(9600);
  for(i=0;i<(sizeof(LED)/sizeof(LED[0]));i++){
    pinMode(LED[i],OUTPUT);
  }
  delay(9000);//delay 5 seconds so fan gets up to speed
  subcount=1;
  while(rev<21){//21 is arbitrary. All we do is let the fan pass the magnet 20 times to calibrate/calculate the spin frequency!
   if(analogRead(hall)>thresh) {
      if (subcount==1){//first detection, we start the timer
        t_0=millis();//  this is the starting the timer; we will compare the recorded time to the 20 spins!
        subcount++;
      }
      else{
      rev++;
      }
      while(analogRead(hall)>thresh){
      //we wait in this loop until hallstate returns to 0
      }
   }
  } 
  t_1=millis();//recording time of 20 revolutions
  //Quantities for use in frequency matching
  w=floor((20*2*pi*1000/(t_1-t_0)));//fan angular frequency
  t_off=floor((1000000*tol/(rad*w)));//in microseconds
  t_on=t_off/10;//microseconds
}




void letterwrite5(boolean letter[5][5], int t_on, int t_off,const int LED[5] ){
  int w_temp = 5;//;letter width is 5
  for (width=0;width<w_temp;width=width+1){
    for (height=0;height<5;height=height+1){
      digitalWrite(LED[height],letter[height][width]);
    }
    delayMicroseconds(t_on);
    for (height=0;height<5;height=height+1){
      digitalWrite(LED[height],0);
    }
    delayMicroseconds(t_off);
  }
}

void letterwrite4(boolean letter[5][4], int t_on, int t_off,const int LED[5] ){
  int w_temp = 4;//;letter width is 5
  for (width=0;width<w_temp;width=width+1){
    for (height=0;height<5;height=height+1){
      digitalWrite(LED[height],letter[height][width]);
    }
    delayMicroseconds(t_on);
    for (height=0;height<5;height=height+1){
      digitalWrite(LED[height],0);
    }
    delayMicroseconds(t_off);
  }
}

void spacewrite(int t_off,const int LED[5] ){
    for (height=0;height<5;height=height+1){
      digitalWrite(LED[height],0);
    }
    delayMicroseconds(t_off);
}

void loop() {
  if (analogRead(hall)>thresh){
    letterwrite5(G,t_on,t_off,LED);
    spacewrite(t_off,LED);
    letterwrite4(E,t_on,t_off,LED);
    spacewrite(t_off,LED);
    letterwrite5(T,t_on,t_off,LED);
    spacewrite(t_off,LED);
    spacewrite(t_off,LED);
    letterwrite4(F,t_on,t_off,LED);
    spacewrite(t_off,LED);
    letterwrite4(U,t_on,t_off,LED);
    spacewrite(t_off,LED);
    letterwrite4(C,t_on,t_off,LED);
    spacewrite(t_off,LED);
    letterwrite4(K,t_on,t_off,LED);
    spacewrite(t_off,LED);
    letterwrite4(E,t_on,t_off,LED);
    spacewrite(t_off,LED);
    letterwrite5(D,t_on,t_off,LED);
    //while (analogRead(hall)>thresh){
    //we wait here for signal to go low
    //} maybe bring this back, should be fine without because the magnet should not be near the sensor after display
  }
}
